package main

import (
	"time"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"io/ioutil"
	"strings"
	"regexp"

	"github.com/restic/restic/internal/errors"
	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
)

var cmdGenerate = &cobra.Command{
	Use:   "generate [command]",
	Short: "Generate manual pages and auto-completion files (bash, zsh)",
	Long: `
The "generate" command writes automatically generated files like the man pages
and the auto-completion files for bash and zsh).
`,
	DisableAutoGenTag: true,
	RunE:              runGenerate,
}

type generateOptions struct {
	ManDir             string
	BashCompletionFile string
	ZSHCompletionFile  string
}

var genOpts generateOptions

func init() {
	cmdRoot.AddCommand(cmdGenerate)
	fs := cmdGenerate.Flags()
	fs.StringVar(&genOpts.ManDir, "man", "", "write man pages to `directory`")
	fs.StringVar(&genOpts.BashCompletionFile, "bash-completion", "", "write bash completion `file`")
	fs.StringVar(&genOpts.ZSHCompletionFile, "zsh-completion", "", "write zsh completion `file`")
}

func writeManpages(dir string) error {
	// use a fixed date for the man pages so that generating them is deterministic
	date, err := time.Parse("Jan 2006", "Jan 2017")
	if err != nil {
		return err
	}

	header := &doc.GenManHeader{
		Title:   "restic backup",
		Section: "1",
		Source:  "generated by `restic generate`",
		Date:    &date,
	}

	Verbosef("writing man pages to directory %v\n", dir)
	err = writeManPagesForDoc("./doc", dir)
	if err != nil {
		return nil
	}
	return doc.GenManTree(cmdRoot, header, dir)
}

// TODO error handling
func writeManPagesForDoc(directory string, outputDir string) error {
	matches, err := filepath.Glob(filepath.Join(directory, "*.rst"))
	if err != nil {
		return err
	}

	for _, file := range matches {
		basename := string(regexp.MustCompile(`^\d+_`).ReplaceAll([]byte(path.Base(file)), []byte("")))
		withoutSuffix := strings.TrimSuffix(basename, path.Ext(basename))
		cleanBase := string(regexp.MustCompile(`\W`).ReplaceAll([]byte(withoutSuffix), []byte("-")))
		name := fmt.Sprintf("restic-doc-%s", cleanBase)
		outputFilename := path.Join(outputDir, fmt.Sprintf("%s.1", name))

		content, err := ioutil.ReadFile(file)
		if err != nil {
			return err
		}
		manContent := fmt.Sprintf(".TH \"%s\" \"1\" \"Jan 2017\" \"generated by `restic generate`\" \"\" \n.nh \n.ad l \n\n.PP %s\n\n", name, content)

		f, err := os.Create(outputFilename)
		if err != nil {
			return err
		}
		defer f.Close()

		_, err = f.Write([]byte(manContent))
		if err != nil {
			return err
		}
	}

	return nil
}

func writeBashCompletion(file string) error {
	Verbosef("writing bash completion file to %v\n", file)
	return cmdRoot.GenBashCompletionFile(file)
}

func writeZSHCompletion(file string) error {
	Verbosef("writing zsh completion file to %v\n", file)
	return cmdRoot.GenZshCompletionFile(file)
}

func runGenerate(cmd *cobra.Command, args []string) error {
	if genOpts.ManDir != "" {
		err := writeManpages(genOpts.ManDir)
		if err != nil {
			return err
		}
	}

	if genOpts.BashCompletionFile != "" {
		err := writeBashCompletion(genOpts.BashCompletionFile)
		if err != nil {
			return err
		}
	}

	if genOpts.ZSHCompletionFile != "" {
		err := writeZSHCompletion(genOpts.ZSHCompletionFile)
		if err != nil {
			return err
		}
	}

	var empty generateOptions
	if genOpts == empty {
		return errors.Fatal("nothing to do, please specify at least one output file/dir")
	}

	return nil
}
